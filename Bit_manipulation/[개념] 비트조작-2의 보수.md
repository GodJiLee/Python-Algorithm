## **비트조작 - 2의 보수**
### **2의 보수 숫자 포맷**
2의 보수는 컴퓨터가 음수를 저장하기 위해 취하는 방법 중 하나   
자리수를 절반으로 쪼개서 반은 음수 몫으로 할당함


```python
# 자릿수 제한 비트 연산
MASK = 0xF
bin(1 & MASK)
```




    '0b1'



2의 보수 숫자 포맷을 나타내기 위해 MASK를 사용함   
이로써 4비트로 2의 보수를 표현할 수 있음


```python
bin(7 & MASK)
```




    '0b111'




```python
bin(-8 & MASK)
```




    '0b1000'




```python
bin(-7 & MASK)
```




    '0b1001'




```python
bin(7)
```




    '0b111'




```python
# 파이썬 내부적으로는 2의 보수를 보여주지 않음
bin(-8)
```




    '-0b1000'



파이썬은 부호는 별도 필드로 갖고 있으며, 비트 연산이 필요할 때만 2의 보수로 변환하는 작업을 함   
음수를 표현할 때도 양의 정수를 표현할 때와 동일하게 표현하고 앞에 부호만 붙임


```python
bin(8)
```




    '0b1000'




```python
# AND 연산
5 & -4
```




    4




```python
# 4비트 2의 보수
bin(0b0101 & 0b1100)
```




    '0b100'




```python
# 32비트 2의 보수
bin(0b00000000000000000000000000000101 & 0b11111111111111111111111111111100)
```




    '0b100'




```python
int(0b100)
```




    4




```python
# OR 연산
5 | -4
```




    -3




```python
bin(0b0101 | 0b1100)
```




    '0b1101'




```python
bin(0b00000000000000000000000000000101 | 0b11111111111111111111111111111100)
```




    '0b11111111111111111111111111111101'



### **2의 보수 수학 연산 - 부호를 바꿔줌**   
2의 보수는 숫자 포맷으로 쓰일 때와 수학 연산자로 쓰일 때 서로 다른 의미를 갖는다.    
> 수학 연산자로서 2의 보스는 가산의 역 연산
1. 비트연산자 NOT은 2의 보수에서 1을 뺀 연산
2. 2의 보수 수학 연산은 비트연산자 NOT에서 1을 더한 연산

### **비트 연산자 NOT**
- 0을 1로, 1을 0으로 바꿔줌


```python
bin(0b0101 ^ ~ 0b1100) # 입력값이 4비트 포맷이 아님
```




    '-0b1010'



오버플로 발생으로 더 큰 포맷으로 변경해줘야 함


```python
# 8비트 포맷으로 변경
bin(0b00000101 ^ ~0b00001100)
```




    '-0b1010'




```python
bin(0b00000101 ^ 0b11110011)
```




    '0b11110110'




```python
# 16비트일 때도 동일함
bin(0b0000000000000101 ^ ~0b0000000000001100)
```




    '-0b1010'


